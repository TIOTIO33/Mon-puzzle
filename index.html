<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mon Puzzle</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #fafafa;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      font-family: sans-serif;
    }
    #puzzle-board {
      flex: 1;
      display: grid;
      justify-content: center;
      align-content: center;
      gap: 2px;
      background: #333;
    }
    .slot {
      background: #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
    }
    #pieces-bar {
      display: flex;
      overflow-x: auto;
      background: rgba(0,0,0,0.7);
      padding: 8px;
      align-items: center;
      justify-content: flex-start;
    }
    .piece {
      border: 2px solid #fff;
      border-radius: 6px;
      margin-right: 6px;
      cursor: grab;
      width: auto;
      height: auto;
    }
    .piece:active {
      cursor: grabbing;
    }
    #setup {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.9);
      border-radius: 8px;
      padding: 5px 10px;
      z-index: 99;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.95);
      padding: 20px;
      border-radius: 10px;
      font-size: 1.5em;
      display: none;
      color: #28a745;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>

<div id="setup">
  <input type="file" id="imageInput" accept="image/*">
  <label for="gridSize">Pièces:</label>
  <select id="gridSize">
    ${[...Array(13)].map((_, i) => `<option value="${i+3}">${i+3}x${i+3}</option>`).join('')}
  </select>
</div>

<div id="puzzle-board"></div>
<div id="pieces-bar"></div>
<div id="message">Bravo, puzzle terminé !</div>

<script>
let img = new Image();
const board = document.getElementById('puzzle-board');
const bar = document.getElementById('pieces-bar');
const gridSelect = document.getElementById('gridSize');
const imageInput = document.getElementById('imageInput');
const message = document.getElementById('message');

imageInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = evt => {
      img.onload = () => createPuzzle();
      img.src = evt.target.result;
    };
    reader.readAsDataURL(file);
  }
});

function createPuzzle() {
  let size = parseInt(gridSelect.value);
  board.innerHTML = '';
  bar.innerHTML = '';
  message.style.display = 'none';

  const maxW = window.innerWidth * 0.98;
  const maxH = window.innerHeight * 0.7;
  const pieceSize = Math.min(maxW / size, maxH / size);

  board.style.gridTemplateColumns = `repeat(${size}, ${pieceSize}px)`;
  board.style.gridTemplateRows = `repeat(${size}, ${pieceSize}px)`;

  for (let i = 0; i < size * size; i++) {
    let slot = document.createElement('div');
    slot.className = 'slot';
    slot.style.width = pieceSize + 'px';
    slot.style.height = pieceSize + 'px';
    slot.dataset.index = i;
    slot.ondragover = e => e.preventDefault();
    slot.ondrop = dropPiece;
    board.appendChild(slot);
  }

  for (let i = 0; i < size * size; i++) {
    let canvas = document.createElement('canvas');
    canvas.width = pieceSize;
    canvas.height = pieceSize;
    let ctx = canvas.getContext('2d');
    let sx = (i % size) * (img.width / size);
    let sy = Math.floor(i / size) * (img.height / size);
    ctx.drawImage(img, sx, sy, img.width / size, img.height / size, 0, 0, pieceSize, pieceSize);
    canvas.className = 'piece';
    canvas.dataset.index = i;
    canvas.draggable = true;
    canvas.ondragstart = e => e.dataTransfer.setData('text/plain', i);
    bar.appendChild(canvas);
  }
  shufflePieces();
}

function shufflePieces() {
  for (let i = bar.children.length; i > 0; i--) {
    bar.appendChild(bar.children[Math.floor(Math.random() * i)]);
  }
}

function dropPiece(e) {
  const index = e.dataTransfer.getData('text/plain');
  if (this.dataset.index === index) {
    const piece = [...bar.children].find(p => p.dataset.index === index);
    if (piece) {
      this.innerHTML = '';
      this.appendChild(piece);
      piece.draggable = false;
      checkWin();
    }
  } else {
    alert("Essaie encore, mauvaise case !");
  }
}

function checkWin() {
  let slots = document.querySelectorAll('.slot');
  let correct = 0;
  slots.forEach(slot => {
    if (slot.children.length > 0 && slot.children[0].dataset.index === slot.dataset.index) {
      correct++;
    }
  });
  if (correct === slots.length) {
    message.style.display = 'block';
  }
}
</script>

</body>
</html>
